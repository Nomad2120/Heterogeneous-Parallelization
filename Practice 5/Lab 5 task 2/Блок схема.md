```mermaid
flowchart TD
    A([старт]) --> B[задать threads blocks capacity]
    B --> C[выделить память gpu для стека и очереди]
    C --> D[создать cudaEvent]
    D --> E[запуск stack_kernel + замер]
    E --> F[запуск queue_kernel + замер]
    F --> G[копировать результаты на cpu]
    G --> H[проверка стека]
    H --> I{стек корректен}
    I -- нет --> J[стек: неуспешно]
    I -- да --> K[стек: успешно]
    J --> L[проверка очереди]
    K --> L
    L --> M{очередь корректна}
    M -- нет --> N[очередь: неуспешно]
    M -- да --> O[очередь: успешно]
    N --> P[сравнение времени]
    O --> P
    P --> Q([конец])

    subgraph SGPU["CUDA ядро: stack_kernel"]
        S1[tid = global id] --> S2{tid = 0}
        S2 -- да --> S3[top = 0]
        S2 -- нет --> S4[пропустить]
        S3 --> S5[barrier]
        S4 --> S5

        S5 --> S6{tid четный}
        S6 -- да --> S7[push: pos = atomicAdd top]
        S7 --> S8{pos < capacity}
        S8 -- да --> S9[data pos = tid]
        S8 -- нет --> S10[откат top]

        S6 -- нет --> S11[pop: pos = atomicSub top - 1]
        S11 --> S12{pos >= 0}
        S12 -- да --> S13[v = data pos]
        S12 -- нет --> S14[откат top]
    end

    subgraph QGPU["CUDA ядро: queue_kernel"]
        Q1[tid = global id] --> Q2{tid = 0}
        Q2 -- да --> Q3[head = 0; tail = 0]
        Q2 -- нет --> Q4[пропустить]
        Q3 --> Q5[barrier]
        Q4 --> Q5

        Q5 --> Q6{tid четный}
        Q6 -- да --> Q7[enqueue: pos = atomicAdd tail]
        Q7 --> Q8{pos < capacity}
        Q8 -- да --> Q9[data pos = tid]
        Q8 -- нет --> Q10[откат tail]

        Q6 -- нет --> Q11[dequeue: pos = atomicAdd head]
        Q11 --> Q12[прочитать tail_now]
        Q12 --> Q13{pos < tail_now}
        Q13 -- да --> Q14[v = data pos]
        Q13 -- нет --> Q15[откат head]
    end
